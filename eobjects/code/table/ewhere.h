/**

  @file    ewhere.h
  @brief   Where clause interprenter.
  @author  Pekka Lehtikoski
  @version 1.0
  @date    9.11.2011

  Where clause interpenter.

  Copyright 2012 Pekka Lehtikoski. This file is part of the eobjects project and shall only be used, 
  modified, and distributed under the terms of the project licensing. By continuing to use, modify,
  or distribute this file you indicate that you have read the license and understand and accept 
  it fully.

****************************************************************************************************
*/
#ifndef EWHERE_INCLUDED
#define EWHERE_INCLUDED

class eBuffer;

/** Execution stack item
 */
typedef struct eStackItem
{
    /** Value in stack.
     */
    union
    {
        os_double d;
        os_long l;
        os_char *s;
    }
    value;

    /** Data type for value, one of: OS_LONG, OS_DOUBLE or OS_STR.
     */
    osalTypeId datatype;

    /** OS_FALSE if value is from constant, OS_TRUE if from variable.
     */
    os_boolean is_variable;

    /** OS_TRUE if variable is empty.
     */
    os_boolean is_empty;
}
eStackItem;


/**
****************************************************************************************************

  @brief Where clause interpenter.

  The eWhere class interprents and evaluates a where clause. The where clause here is simplified
  SQL where clause.

****************************************************************************************************
*/
class eWhere : public eObject
{
public:
    /**
    ************************************************************************************************

      @name Generic object functionality.

      These functions enable using this class as generic eObject.

    ************************************************************************************************
    */
    /*@{*/

    /* Constructor.
	 */
    eWhere(
		eObject *parent = OS_NULL,
        e_oid id = EOID_RITEM,
		os_int flags = EOBJ_DEFAULT);

    /* Get class identifier.
     */
    virtual os_int classid()
    {
        return ECLASSID_WHERE;
    }

    /*@}*/

	/** 
	************************************************************************************************

      @name Evaluating where clause.

      First call compile function to generate code and list of needed variables. Then set
      values for variables and call evaluate to see of where clause is true or false.

	************************************************************************************************
	*/
	/*@{*/

    /* Compile where clause. Generates byte code and variables.
     */
    eStatus compile(
        os_char *whereclause);

    /* Get pointer to eContainer holding variables.
     */
    inline eContainer *variables()
    {
        return m_vars;
    }

    /* Get number of variables.
     */
    inline os_int nvars()
    {
        return m_nvars;
    }

    /* Evaluate where clause with given set of variable values.
     */
    eStatus evaluate();

    /*@}*/

protected:
    /**
    ************************************************************************************************

      @name Internal to where clause interprenter.

      Protected functions and member variables.

    ************************************************************************************************
    */
    /*@{*/
    os_boolean expression();
    os_boolean simple_expression();
    os_boolean element();
    os_boolean column_name();
    os_boolean number_or_column_name();
    os_boolean string_constant();
    os_short addlong(os_long l);
    os_short adddouble(os_double d);
    os_short addstring(os_char *str, os_memsz len);
    os_short addvariable(os_char *name, os_memsz len);

    void skipspace();
    os_char *getword();
    void code(os_short op);

    void checkstacksize();
    void pushconstant(os_short id);
    void pushvariable(os_short id);

    eStatus evalunaryop(os_short op);
    eStatus evalbinaryop(os_short op);
    void changedatatype(eStackItem *item, osalTypeId datatype);


    /** Container for variables, exists always, has name space.
     */
    eContainer *m_vars;

    /** Container for constants, exists always.
     */
    eContainer *m_constants;

    /** Number of variables in m_vars.
     */
    os_int m_nvars;

    /** Number of constants in m_constants.
     */
    os_int m_nconstants;

    /** Current parse position within expression given as argument to compile().
     */
    os_char *m_pos;

    /** Generated byte code, always exists.
     */
    eBuffer *m_code;

    /** Execution stack, always exists.
     */
    eBuffer *m_stack;

    /** Stack pointer, index where to push next.
     */
    os_int m_stack_ptr;

    /** Last error, always exists.
     */
    eVariable *m_error;

    /** Last parsed word, always exists.
     */
    eVariable *m_word;

    /** Temporarty variable for parsing, always exists.
     */
    eVariable *m_tmp;

    /** Temporary variables during execution, used to stores strings.
     */
    eContainer *m_exec_tmp;

    /*@}*/
};

#endif
